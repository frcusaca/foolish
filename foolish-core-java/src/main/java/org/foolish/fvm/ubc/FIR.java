package org.foolish.fvm.ubc;

import org.foolish.ast.AST;
import org.foolish.ast.SearchOperator;

/**
 * Foolish Internal Representation (FIR).
 * The FIR is the internal representation of computation that holds an AST
 * and tracks evaluation progress.
 * <p>
 * <b>IMMUTABILITY CONTRACT:</b>
 * Once a FIR reaches isConstanic() (CONSTANIC or CONSTANT state), it becomes
 * immutable. No fields may be modified after this point. Any attempt to change
 * state will throw IllegalStateException.
 * <p>
 * To create variations of CONSTANIC FIRs, use the copy() method which creates
 * new instances with different target states.
 */
public abstract class FIR implements Cloneable {
    protected final AST ast;
    protected final String comment;
    private boolean initialized;
    protected Nyes nyes;  // Protected to allow cloneConstanic to set state directly
    private FIR parentFir = null;  // The FIR that contains this FIR (set during enqueue)
    private final boolean ai;      // Auto-instruction: true if FIR was auto-generated (no AST)

    protected FIR(AST ast, String comment, boolean ai) {
        this.ast = ast;
        this.comment = comment;
        this.initialized = false;
        this.nyes = Nyes.UNINITIALIZED;
        this.ai = ai;
    }

    protected FIR(AST ast, String comment) {
        this(ast, comment, false);  // Default: not auto-generated
    }

    protected FIR(AST ast) {
        this(ast, null, false);
    }

    /**
     * Auto-instruction constructor for FIRs without AST.
     * Used when FIR is auto-generated by the system rather than parsed.
     */
    protected FIR(String comment) {
        this(null, comment, true);
    }

    /**
     * Returns the AST node associated with this FIR.
     * May be null for auto-generated FIRs.
     */
    public AST ast() {
        return ast;
    }

    /**
     * Returns the optional comment for this FIR.
     */
    public String comment() {
        return comment;
    }

    /**
     * Returns true if this FIR was auto-generated (auto-instruction).
     * Auto-generated FIRs have no associated AST and are created by the system
     * rather than being parsed from source code.
     */
    public boolean isAi() {
        return ai;
    }

    /**
     * Returns the source location for this FIR.
     * Returns UNKNOWN for auto-generated FIRs without AST.
     */
    public AST.SourceLocation sourceLocation() {
        if (ast != null) {
            return ast.sourceLocation();
        }
        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Finds the nearest source location by walking up the FIR parent chain.
     * Returns the first non-UNKNOWN location found, or UNKNOWN if none exist.
     */
    public AST.SourceLocation nearestSourceLocation() {
        // Try this FIR's location first
        AST.SourceLocation loc = sourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            return loc;
        }

        // Walk up parent chain
        FIR current = parentFir;
        while (current != null) {
            loc = current.sourceLocation();
            if (loc != AST.SourceLocation.UNKNOWN) {
                return loc;
            }
            current = current.parentFir;
        }

        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Gets the statement number of this FIR within its containing brane.
     * Returns -1 if not in a brane or if position cannot be determined.
     */
    public int getStatementNumber() {
        BraneFiroe containingBrane = getMyBrane();
        if (containingBrane != null) {
            return containingBrane.getStatementIndex(this);
        }
        return -1;
    }

    /**
     * Returns a comprehensive location description including:
     * - Source file location (nearest in parent chain)
     * - Statement number in containing brane
     * - Auto-generated marker if applicable
     */
    public String getLocationDescription() {
        StringBuilder sb = new StringBuilder();

        AST.SourceLocation nearest = nearestSourceLocation();
        sb.append(nearest.toString());

        int stmtNum = getStatementNumber();
        if (stmtNum >= 0) {
            sb.append(" (statement #").append(stmtNum + 1).append(")");
        }

        if (isAi()) {
            sb.append(" [auto-generated]");
        }

        return sb.toString();
    }

    /**
     * Finds the first ancestral brane (walking up parent chain) that has a known source location.
     * Returns the brane's line number, or 0 if no ancestral brane with location is found.
     * <p>
     * Note: The root brane always exists (worst case line 0), so this will always return a value.
     *
     * @return the line number of the first ancestral brane with a source location
     */
    public int getAncestralBraneLineNumber() {
        FIR current = this;
        while (current != null) {
            if (current instanceof BraneFiroe) {
                AST.SourceLocation loc = current.sourceLocation();
                if (loc != AST.SourceLocation.UNKNOWN) {
                    return loc.line();
                }
                // If brane has unknown location, keep searching up
            }
            current = current.parentFir;
        }
        // No ancestral brane found with location - return 0 (root brane default)
        return 0;
    }

    /**
     * Formats an error message with the standard 3-item format:
     * 1. Source filename (from ExecutionContext)
     * 2. Line number or [ai] if unknown
     * 3. First ancestral brane line number (Brane@#)
     * <p>
     * Format: "filename.foo:line# Brane@# - message"
     * or: "filename.foo:[ai] Brane@# - message"
     *
     * @param message the error message to format
     * @return the formatted error message
     */
    public String formatErrorMessage(String message) {
        StringBuilder sb = new StringBuilder();

        // 1. Source filename
        ExecutionContext ctx = ExecutionContext.getCurrent();
        if (ctx != null) {
            sb.append(ctx.getSourceFilename());
        } else {
            sb.append("unknown.foo");
        }
        sb.append(":");

        // 2. Line number or [ai]
        AST.SourceLocation loc = nearestSourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            sb.append("line ").append(loc.line());
        } else if (isAi()) {
            sb.append("[ai]");
        } else {
            sb.append("unknown");
        }

        // 3. Ancestral brane line number
        int braneLineNum = getAncestralBraneLineNumber();
        sb.append(" Brane@").append(braneLineNum);

        // Append the actual message
        sb.append(" - ").append(message);

        return sb.toString();
    }

    /**
     * Returns whether this FIR has been initialized.
     */
    protected boolean isInitialized() {
        return initialized;
    }

    /**
     * Sets the initialized flag of this FIR.
     * This is separate from the Nyes state and tracks basic initialization.
     */
    protected void setInitialized() {
        this.initialized = true;
    }

    /**
     * Sets both the initialized flag and transitions to INITIALIZED Nyes state.
     * This is the recommended way to mark a FIR as initialized.
     */
    protected void markInitialized() {
        this.initialized = true;
        setNyesInitialized();
    }

    /**
     * Returns the current NYE state of this FIR.
     */
    protected Nyes getNyes() {
        return nyes;
    }

    /**
     * Sets the NYE state of this FIR.
     * All changes to a Firoe's Nyes must be made through this method.
     *
     * @deprecated Use state-specific setters instead (setUninitialized, setInitialized, etc.)
     *             This method remains for backward compatibility but will be removed.
     */
    @Deprecated
    protected void setNyes(Nyes nyes) {
        // Check immutability constraint - use direct field check, not getNyes()
        // because subclasses like CMFir override getNyes() to return inner state
        if (this.nyes != null &&
            this.nyes.ordinal() >= Nyes.CONSTANIC.ordinal() &&
            nyes != Nyes.CONSTANT) {
            throw new IllegalStateException(
                formatErrorMessage("Cannot change state from " + this.nyes + " to " + nyes +
                                  " - FIR is immutable once CONSTANIC"));
        }
        this.nyes = nyes;
    }

    /**
     * Transitions to UNINITIALIZED Nyes state.
     * Only allowed from constructor - enforces proper initialization.
     */
    protected void setNyesUninitialized() {
        if (nyes != null && nyes != Nyes.UNINITIALIZED) {
            throw new IllegalStateException(
                formatErrorMessage("Cannot transition to UNINITIALIZED from " + nyes));
        }
        this.nyes = Nyes.UNINITIALIZED;
    }

    /**
     * Transitions to INITIALIZED Nyes state.
     * Only allowed before CONSTANIC state.
     */
    protected void setNyesInitialized() {
        if (isConstanic()) {
            throw new IllegalStateException(
                formatErrorMessage("Cannot change state to INITIALIZED - FIR is immutable once CONSTANIC"));
        }
        this.nyes = Nyes.INITIALIZED;
    }

    /**
     * Transitions to CHECKED Nyes state.
     * Only allowed before CONSTANIC state.
     */
    protected void setNyesChecked() {
        if (isConstanic()) {
            throw new IllegalStateException(
                formatErrorMessage("Cannot change state to CHECKED - FIR is immutable once CONSTANIC"));
        }
        this.nyes = Nyes.CHECKED;
    }

    /**
     * Transitions to EVALUATING Nyes state.
     * Only allowed before CONSTANIC state.
     */
    protected void setNyesEvaluating() {
        if (isConstanic()) {
            throw new IllegalStateException(
                formatErrorMessage("Cannot change state to EVALUATING - FIR is immutable once CONSTANIC"));
        }
        this.nyes = Nyes.EVALUATING;
    }

    /**
     * Transitions to CONSTANIC Nyes state.
     * Once set, FIR becomes immutable and only CONSTANT transition is allowed.
     * Only allowed before CONSTANIC state.
     */
    protected void setNyesConstanic() {
        if (isConstanic()) {
            // Already CONSTANIC or CONSTANT, no-op
            return;
        }
        this.nyes = Nyes.CONSTANIC;
    }

    /**
     * Transitions to CONSTANT Nyes state.
     * This is the only state transition allowed from CONSTANIC.
     * Once CONSTANT, no further transitions are possible.
     */
    protected void setNyesConstant() {
        this.nyes = Nyes.CONSTANT;
    }

    /**
     * Sets the parent FIR that contains this FIR.
     * This is called when this FIR is enqueued into a parent's braneMind.
     */
    protected void setParentFir(FIR parent) {
        this.parentFir = parent;
    }

    /**
     * Gets the parent FIR that contains this FIR.
     * Returns null if this FIR has no parent (e.g., root brane).
     */
    protected FIR getParentFir() {
        return parentFir;
    }

    public boolean atConstant() {
        return getNyes() == Nyes.CONSTANT;
    }

    public boolean atConstanic() {
        return getNyes() == Nyes.CONSTANIC;
    }

    /**
     * Perform one step of evaluation on this FIR.
     * This method should advance the FIR's evaluation state by one step.
     * For simple values that don't require stepping, this can be a no-op.
     *
     * @return the amount of work done in this step:
     *         0 for empty transitions (no-op, already evaluated, or waiting)
     *         1 for meaningful work (state transitions, evaluations, searches)
     *         Values are accumulated for step counting
     */
    public abstract int step();

    /**
     * Query method returning false if an additional step on this FIR does not change it.
     * Returns true when an additional step would change the FIR.
     * Not Yet Evaluated (NYE) indicates the FIR requires further evaluation steps.
     * Anything before CONSTANIC is considered NYE.
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     */
    public boolean isNye() {
        return getNyes().ordinal() < Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANIC or later (CONSTANT).
     * Something that is CONSTANT is also Constanic.
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     */
    public boolean isConstanic() {
        return getNyes().ordinal() >= Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANT or later (which is just CONSTANT).
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     */
    public boolean isConstant() {
        return getNyes().ordinal() >= Nyes.CONSTANT.ordinal();
    }

    /**
     * Gets the value from this FIR if it represents a simple value.
     * For ValueFiroe and evaluated expressions, returns the integer value.
     *
     * @return the integer value
     * @throws UnsupportedOperationException if this FIR doesn't support getValue
     * @throws IllegalStateException         if this FIR is not fully evaluated
     */
    public long getValue() {
        throw new UnsupportedOperationException("getValue not supported for " + getClass().getSimpleName());
    }

    /**
     * Gets the BraneFiroe that contains this FIR in its statement list.
     * Chains through parent FIRs until finding one whose parent is a BraneFiroe.
     * <p>
     * The containing brane is the closest BraneFiroe in the FIR hierarchy,
     * representing the brane where this FIR appears as a statement.
     * <p>
     * Parallel expressions (such as operands in a+b) are at the "same height"
     * and all statements in a brane are parallel/same height. The height does
     * NOT deepen with deepening FIR structures - height only changes when
     * crossing brane boundaries.
     *
     * @return the containing BraneFiroe, or null if this FIR is not contained
     *         in a brane (e.g., at root level)
     */
    public BraneFiroe getMyBrane() {
        // Chain through parents until we find one whose parent is a BraneFiroe
        if (parentFir instanceof BraneFiroe bf) {
            return bf;
        }
        if (parentFir == null) {
            return null;
        }
        return parentFir.getMyBrane();
    }

    /**
     * Gets the hierarchical index of this FIR statement.
     * The index starts with 0 (root) and appends the statement index at each level.
     * Format example: [0, 0, 1, 2]
     */
    public FoolishIndex getMyIndex() {
        FoolishIndexBuilder builder = new FoolishIndexBuilder();
        FIR current = this;

        // Traverse up the hierarchy
        while (current != null) {
            int index = current.getMyBraneIndex();
            if (index == -1) {
                // We reached the top (root or detached)
                // "Index always starts with 0"
                builder.prepend(0);
                break;
            } else {
                builder.prepend(index);
                // Move to the containing brane
                current = current.getMyBrane();
            }
        }

        return builder.build();
    }

    /**
     * Gets the index of this FIR in its containing brane's memory.
     * Chains through parent FIRs to find the statement-level FIR, then returns its position.
     * <p>
     * The brane index defines the "order of expressions" within a height level.
     * All statements at the same brane level are parallel/same height, and the
     * index orders them for operations like unanchored backward search.
     * <p>
     * Note: The index is for the statement containing this FIR, not necessarily
     * this exact FIR object. For example, if this is a sub-expression of an
     * assignment, it returns the assignment's index in the brane.
     *
     * @return the index in the containing brane's memory (0-based), or -1 if
     *         this FIR is not in a brane (root level)
     */
    public int getMyBraneIndex() {
        return switch (parentFir) {
            case null ->  -1;
	    case BraneFiroe bf -> bf.getIndexOf(this);
	    default -> parentFir.getMyBraneIndex();
	};
    }

    /**
     * Creates a copy of this FIR with optional target state.
     * <p>
     * This is the unified copying mechanism for all FIRs. The behavior depends on:
     * - If targetNyes is specified and different: clone and set new state
     * - If FIR is CONSTANIC and no target: return this (immutable, safe to share)
     * - Otherwise: wrap in CMFir for deferred context-sensitive copying
     *
     * @param targetNyes target Nyes state for the copy, or null to preserve current state
     * @return a copy of this FIR (may be this if immutable, or wrapped in CMFir)
     */
    public FIR copy(Nyes targetNyes) {
        // If target state specified and different, clone and set new state
        if (targetNyes != null && nyes != targetNyes) {
            FIR fresh = this.clone();
            // Set nyes directly - this is the ONLY place where we bypass setNyes()
            // Direct assignment is safe here because we just cloned
            fresh.nyes = targetNyes;
            return fresh;
        }
        if (isConstanic()) {
            return this;  // Immutable, safe to share
        } else {
            // Wrap in CMFir for deferred copying in new context
            if (this.ast() instanceof AST.Expr expr) {
                return new CMFir(this.ast(), this);
            } else {
                // Fallback: clone for non-Expr ASTs
                return this.clone();
            }
        }
    }


    /**
     * Creates a shallow clone of this FIR.
     * Subclasses should override to provide deep cloning where needed
     * (e.g., for FIRs with braneMind or other mutable state).
     *
     * @return a shallow clone of this FIR
     */
    @Override
    protected FIR clone() {
        try {
            return (FIR) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Clone not supported for " + getClass().getSimpleName(), e);
        }
    }

    /**
     * Clones a CONSTANIC (or CONSTANT) FIR with updated parent chain.
     * <p>
     * This method is ONLY for cloning CONSTANIC or CONSTANT FIRs. It will throw
     * an exception if called on a FIR that is not constanic.
     * <p>
     * <b>Key behaviors:</b>
     * - CONSTANT FIRs: Returns this (shared completely - they're immutable)
     * - CONSTANIC FIRs: Creates a clone with updated parent chain to enable re-evaluation
     * <p>
     * <b>Lemma:</b> CONSTANT FIR cannot have non-CONSTANT children (fully immutable tree).
     * Therefore, CONSTANT FIRs can be shared completely without cloning.
     * <p>
     * <b>For CONSTANIC FIRs:</b> Parent chain must be updated to point to new objects
     * to enable re-evaluation in a new context. The clone uses a copy constructor
     * that recursively calls cloneConstanic on children with updated parents.
     *
     * @param newParent the new parent FIR for this clone
     * @param targetNyes optional target state; if present, sets clone to this state;
     *                   if empty, copies state from original
     * @return a clone with updated parent chain (CONSTANIC), or this (CONSTANT)
     * @throws IllegalStateException if called on a FIR that is not constanic
     */
    protected FIR cloneConstanic(FIR newParent, java.util.Optional<Nyes> targetNyes) {
        if (!isConstanic()) {
            throw new IllegalStateException(
                formatErrorMessage("cloneConstanic can only be called on CONSTANIC or CONSTANT FIRs, " +
                                  "but this FIR is in state: " + getNyes()));
        }

        if (isConstant()) {
            return this;  // Share CONSTANT FIRs completely (immutable tree)
        }

        // CONSTANIC: clone with new parent chain
        // Default implementation uses shallow clone
        // Subclasses with children (like FiroeWithBraneMind) must override
        FIR copy = this.clone();
        copy.setParentFir(newParent);

        // Set target state if specified, otherwise copy from original
        if (targetNyes.isPresent()) {
            copy.nyes = targetNyes.get();  // Direct assignment bypasses immutability check
        } else {
            copy.nyes = this.nyes;  // Copy original state
        }

        return copy;
    }

    /**
     * Creates a FIR from an AST expression.
     */
    protected static FIR createFiroeFromExpr(AST.Expr expr) {
        switch (expr) {
            case AST.IntegerLiteral literal -> {
                return new ValueFiroe(expr, literal.value());
            }
            case AST.BinaryExpr binary -> {
                return new BinaryFiroe(binary);
            }
            case AST.UnaryExpr unary -> {
                return new UnaryFiroe(unary);
            }
            case AST.IfExpr ifExpr -> {
                return new IfFiroe(ifExpr);
            }
            case AST.Brane brane -> {
                return new BraneFiroe(brane);
            }
            case AST.DetachmentBrane detachBrane -> {
                return new DetachmentBraneFiroe(detachBrane);
            }
            case AST.Assignment assignment -> {
                return new AssignmentFiroe(assignment);
            }
            case AST.Identifier identifier -> {
                return new IdentifierFiroe(identifier);
            }
            case AST.RegexpSearchExpr regexpSearch -> {
                if (DerefSearchFiroe.isExactMatch(regexpSearch.pattern())) {
                    return new DerefSearchFiroe(regexpSearch);
                }
                return new RegexpSearchFiroe(regexpSearch);
            }
            case AST.OneShotSearchExpr oneShotSearch -> {
                return new OneShotSearchFiroe(oneShotSearch);
            }
            case AST.DereferenceExpr dereferenceExpr -> {
                AST.RegexpSearchExpr synthetic = new AST.RegexpSearchExpr(dereferenceExpr.anchor(), SearchOperator.REGEXP_LOCAL, dereferenceExpr.coordinate().toString());
                return new DerefSearchFiroe(synthetic, dereferenceExpr);
            }
            case AST.SeekExpr seekExpr -> {
                return new SeekFiroe(seekExpr);
            }
            case AST.UnanchoredSeekExpr unanchoredSeekExpr -> {
                return new UnanchoredSeekFiroe(unanchoredSeekExpr);
            }
            case AST.StayFoolishExpr stayFoolish -> {
                // SF marker wraps expression in SFMarkFiroe for re-coordination
                FIR innerFir = createFiroeFromExpr(stayFoolish.expr());
                return new SFMarkFiroe(stayFoolish, innerFir);
            }
            case AST.StayFullyFoolishExpr stayFullyFoolish -> {
                // SFF marker (<<==>> syntax) is temporarily disabled
                return new NKFiroe("SFF marker (<<==>> syntax) not yet implemented");
            }
            default -> {
                // Placeholder for unsupported types
                return new NKFiroe();
            }
        }
    }
}

package org.foolish.fvm.ubc;

import org.foolish.ast.AST;
import org.foolish.ast.SearchOperator;

/**
 * Foolish Internal Representation (FIR).
 * The FIR is the internal representation of computation that holds an AST
 * and tracks evaluation progress.
 */
public abstract class FIR {
    protected final AST ast;
    protected final String comment;
    private boolean initialized;
    private Nyes nyes;
    private FIR parentFir = null;  // The FIR that contains this FIR (set during enqueue)
    private final boolean ai;      // Auto-instruction: true if FIR was auto-generated (no AST)

    protected FIR(AST ast, String comment, boolean ai) {
        this.ast = ast;
        this.comment = comment;
        this.initialized = false;
        this.nyes = Nyes.UNINITIALIZED;
        this.ai = ai;
    }

    protected FIR(AST ast, String comment) {
        this(ast, comment, false);  // Default: not auto-generated
    }

    protected FIR(AST ast) {
        this(ast, null, false);
    }

    /**
     * Auto-instruction constructor for FIRs without AST.
     * Used when FIR is auto-generated by the system rather than parsed.
     */
    protected FIR(String comment) {
        this(null, comment, true);
    }

    /**
     * Returns the AST node associated with this FIR.
     * May be null for auto-generated FIRs.
     */
    public AST ast() {
        return ast;
    }

    /**
     * Returns the optional comment for this FIR.
     */
    public String comment() {
        return comment;
    }

    /**
     * Returns true if this FIR was auto-generated (auto-instruction).
     * Auto-generated FIRs have no associated AST and are created by the system
     * rather than being parsed from source code.
     */
    public boolean isAi() {
        return ai;
    }

    /**
     * Returns the source location for this FIR.
     * Returns UNKNOWN for auto-generated FIRs without AST.
     */
    public AST.SourceLocation sourceLocation() {
        if (ast != null) {
            return ast.sourceLocation();
        }
        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Finds the nearest source location by walking up the FIR parent chain.
     * Returns the first non-UNKNOWN location found, or UNKNOWN if none exist.
     */
    public AST.SourceLocation nearestSourceLocation() {
        // Try this FIR's location first
        AST.SourceLocation loc = sourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            return loc;
        }

        // Walk up parent chain
        FIR current = parentFir;
        while (current != null) {
            loc = current.sourceLocation();
            if (loc != AST.SourceLocation.UNKNOWN) {
                return loc;
            }
            current = current.parentFir;
        }

        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Gets the statement number of this FIR within its containing brane.
     * Returns -1 if not in a brane or if position cannot be determined.
     */
    public int getStatementNumber() {
        BraneFiroe containingBrane = getMyBrane();
        if (containingBrane != null) {
            return containingBrane.getStatementIndex(this);
        }
        return -1;
    }

    /**
     * Returns a comprehensive location description including:
     * - Source file location (nearest in parent chain)
     * - Statement number in containing brane
     * - Auto-generated marker if applicable
     */
    public String getLocationDescription() {
        StringBuilder sb = new StringBuilder();

        AST.SourceLocation nearest = nearestSourceLocation();
        sb.append(nearest.toString());

        int stmtNum = getStatementNumber();
        if (stmtNum >= 0) {
            sb.append(" (statement #").append(stmtNum + 1).append(")");
        }

        if (isAi()) {
            sb.append(" [auto-generated]");
        }

        return sb.toString();
    }

    /**
     * Finds the first ancestral brane (walking up parent chain) that has a known source location.
     * Returns the brane's line number, or 0 if no ancestral brane with location is found.
     * <p>
     * Note: The root brane always exists (worst case line 0), so this will always return a value.
     *
     * @return the line number of the first ancestral brane with a source location
     */
    public int getAncestralBraneLineNumber() {
        FIR current = this;
        while (current != null) {
            if (current instanceof BraneFiroe) {
                AST.SourceLocation loc = current.sourceLocation();
                if (loc != AST.SourceLocation.UNKNOWN) {
                    return loc.line();
                }
                // If brane has unknown location, keep searching up
            }
            current = current.parentFir;
        }
        // No ancestral brane found with location - return 0 (root brane default)
        return 0;
    }

    /**
     * Formats an error message with the standard 3-item format:
     * 1. Source filename (from ExecutionContext)
     * 2. Line number or [ai] if unknown
     * 3. First ancestral brane line number (Brane@#)
     * <p>
     * Format: "filename.foo:line# Brane@# - message"
     * or: "filename.foo:[ai] Brane@# - message"
     *
     * @param message the error message to format
     * @return the formatted error message
     */
    public String formatErrorMessage(String message) {
        StringBuilder sb = new StringBuilder();

        // 1. Source filename
        ExecutionContext ctx = ExecutionContext.getCurrent();
        if (ctx != null) {
            sb.append(ctx.getSourceFilename());
        } else {
            sb.append("unknown.foo");
        }
        sb.append(":");

        // 2. Line number or [ai]
        AST.SourceLocation loc = nearestSourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            sb.append("line ").append(loc.line());
        } else if (isAi()) {
            sb.append("[ai]");
        } else {
            sb.append("unknown");
        }

        // 3. Ancestral brane line number
        int braneLineNum = getAncestralBraneLineNumber();
        sb.append(" Brane@").append(braneLineNum);

        // Append the actual message
        sb.append(" - ").append(message);

        return sb.toString();
    }

    /**
     * Returns whether this FIR has been initialized.
     */
    protected boolean isInitialized() {
        return initialized;
    }

    /**
     * Sets the initialized state of this FIR.
     */
    protected void setInitialized() {
        this.initialized = true;
    }

    /**
     * Returns the current NYE state of this FIR.
     */
    protected Nyes getNyes() {
        return nyes;
    }

    /**
     * Sets the NYE state of this FIR.
     * All changes to a Firoe's Nyes must be made through this method.
     */
    protected void setNyes(Nyes nyes) {
        this.nyes = nyes;
    }

    /**
     * Sets the parent FIR that contains this FIR.
     * This is called when this FIR is enqueued into a parent's braneMind.
     */
    protected void setParentFir(FIR parent) {
        this.parentFir = parent;
    }

    /**
     * Gets the parent FIR that contains this FIR.
     * Returns null if this FIR has no parent (e.g., root brane).
     */
    protected FIR getParentFir() {
        return parentFir;
    }

    public final boolean atConstant() {
        return nyes == Nyes.CONSTANT;
    }

    public final boolean atConstanic() {
        return nyes == Nyes.CONSTANIC;
    }

    /**
     * Perform one step of evaluation on this FIR.
     * This method should advance the FIR's evaluation state by one step.
     * For simple values that don't require stepping, this can be a no-op.
     *
     * @return the amount of work done in this step:
     *         0 for empty transitions (no-op, already evaluated, or waiting)
     *         1 for meaningful work (state transitions, evaluations, searches)
     *         Values are accumulated for step counting
     */
    public abstract int step();

    /**
     * Query method returning false if an additional step on this FIR does not change it.
     * Returns true when an additional step would change the FIR.
     * Not Yet Evaluated (NYE) indicates the FIR requires further evaluation steps.
     * Anything before CONSTANIC is considered NYE.
     */
    public boolean isNye() {
        return nyes.ordinal() < Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANIC or later (CONSTANT).
     * Something that is CONSTANT is also Constanic.
     */
    public boolean isConstanic() {
        return nyes.ordinal() >= Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANT or later (which is just CONSTANT).
     */
    public boolean isConstant() {
        return nyes.ordinal() >= Nyes.CONSTANT.ordinal();
    }

    /**
     * Gets the value from this FIR if it represents a simple value.
     * For ValueFiroe and evaluated expressions, returns the integer value.
     *
     * @return the integer value
     * @throws UnsupportedOperationException if this FIR doesn't support getValue
     * @throws IllegalStateException         if this FIR is not fully evaluated
     */
    public long getValue() {
        throw new UnsupportedOperationException("getValue not supported for " + getClass().getSimpleName());
    }

    /**
     * Gets the BraneFiroe that contains this FIR in its statement list.
     * Chains through parent FIRs until finding one whose parent is a BraneFiroe.
     * <p>
     * The containing brane is the closest BraneFiroe in the FIR hierarchy,
     * representing the brane where this FIR appears as a statement.
     * <p>
     * Parallel expressions (such as operands in a+b) are at the "same height"
     * and all statements in a brane are parallel/same height. The height does
     * NOT deepen with deepening FIR structures - height only changes when
     * crossing brane boundaries.
     *
     * @return the containing BraneFiroe, or null if this FIR is not contained
     *         in a brane (e.g., at root level)
     */
    public BraneFiroe getMyBrane() {
        // Chain through parents until we find one whose parent is a BraneFiroe
        if (parentFir instanceof BraneFiroe bf) {
		return bf;
	}
	return parentFir.getMyBrane();
    }

    /**
     * Gets the index of this FIR in its containing brane's memory.
     * Chains through parent FIRs to find the statement-level FIR, then returns its position.
     * <p>
     * The brane index defines the "order of expressions" within a height level.
     * All statements at the same brane level are parallel/same height, and the
     * index orders them for operations like unanchored backward search.
     * <p>
     * Note: The index is for the statement containing this FIR, not necessarily
     * this exact FIR object. For example, if this is a sub-expression of an
     * assignment, it returns the assignment's index in the brane.
     *
     * @return the index in the containing brane's memory (0-based), or -1 if
     *         this FIR is not in a brane (root level)
     */
    public int getMyBraneIndex() {
        return switch (parentFir) {
            case null ->  -1;
	    case BraneFiroe bf -> bf.getIndexOf(this);
	    default -> parentFir.getMyBraneIndex();
	};
    }

    /**
     * Gets the hierarchical index of this statement.
     * Index always starts with 0 because the top program is a brane and it starts on line zero by convention.
     * Each subsequent number represents the 0-based statement number in the brane that contains the desired statement.
     *
     * @return the immutable FoolishIndex representing the path to this statement
     */
    public FoolishIndex getMyIndex() {
        FoolishIndexBuilder builder = new FoolishIndexBuilder();
        FIR current = this;

        while (current != null) {
            FIR parent = current.getParentFir();

            if (parent == null) {
                // Reached root
                break;
            }

            // If parent is a BraneFiroe, this FIR (or the chain leading to it) is a statement in it.
            if (parent instanceof BraneFiroe brane) {
                int index = brane.getIndexOf(current);
                if (index != -1) {
                    builder.prepend(index);
                }
            }

            // Move up the chain
            current = parent;
        }

        // Always start with 0 (root)
        builder.prepend(0);

        return builder.build();
    }

    /**
     * Creates a FIR from an AST expression.
     */
    protected static FIR createFiroeFromExpr(AST.Expr expr) {
        switch (expr) {
            case AST.IntegerLiteral literal -> {
                return new ValueFiroe(expr, literal.value());
            }
            case AST.BinaryExpr binary -> {
                return new BinaryFiroe(binary);
            }
            case AST.UnaryExpr unary -> {
                return new UnaryFiroe(unary);
            }
            case AST.IfExpr ifExpr -> {
                return new IfFiroe(ifExpr);
            }
            case AST.Brane brane -> {
                return new BraneFiroe(brane);
            }
            case AST.Assignment assignment -> {
                return new AssignmentFiroe(assignment);
            }
            case AST.Identifier identifier -> {
                return new IdentifierFiroe(identifier);
            }
            case AST.RegexpSearchExpr regexpSearch -> {
                if (DerefSearchFiroe.isExactMatch(regexpSearch.pattern())) {
                    return new DerefSearchFiroe(regexpSearch);
                }
                return new RegexpSearchFiroe(regexpSearch);
            }
            case AST.OneShotSearchExpr oneShotSearch -> {
                return new OneShotSearchFiroe(oneShotSearch);
            }
            case AST.DereferenceExpr dereferenceExpr -> {
                AST.RegexpSearchExpr synthetic = new AST.RegexpSearchExpr(dereferenceExpr.anchor(), SearchOperator.REGEXP_LOCAL, dereferenceExpr.coordinate().toString());
                return new DerefSearchFiroe(synthetic, dereferenceExpr);
            }
            case AST.SeekExpr seekExpr -> {
                return new SeekFiroe(seekExpr);
            }
            case AST.UnanchoredSeekExpr unanchoredSeekExpr -> {
                return new UnanchoredSeekFiroe(unanchoredSeekExpr);
            }
            case AST.StayFoolishExpr stayFoolish -> {
                // SF marker wraps expression in SFFiroe for re-coordination
                FIR innerFir = createFiroeFromExpr(stayFoolish.expr());
                return new SFFiroe(stayFoolish, innerFir);
            }
            case AST.StayFullyFoolishExpr stayFullyFoolish -> {
                // SFF marker reconstructs from AST using SFFFiroe
                FIR innerFir = createFiroeFromExpr(stayFullyFoolish.expr());
                return new SFFFiroe(stayFullyFoolish, innerFir);
            }
            default -> {
                // Placeholder for unsupported types
                return new NKFiroe();
            }
        }
    }
}

package org.foolish.fvm.ubc;

import org.foolish.ast.AST;
import org.foolish.ast.SearchOperator;

/**
 * Foolish Internal Representation (FIR).
 * The FIR is the internal representation of computation that holds an AST
 * and tracks evaluation progress.
 * <p>
 * <b>=== CONSTRAINTS ===</b>
 * <p>
 * <b>C1: IMMUTABILITY AFTER CONSTANIC</b><br>
 * Once a FIR reaches isConstanic() (CONSTANIC or CONSTANT state), it becomes
 * immutable. No fields may be modified after this point. Any attempt to change
 * state will throw IllegalStateException.
 * <p>
 * <b>C2: CONSTANT TREE INVARIANT</b><br>
 * A CONSTANT FIR never has non-CONSTANT descendants.
 * If a FIR is CONSTANT, ALL children are also CONSTANT.
 * Verified: CONSTANT FIRs can be shared without cloning.
 * Implication: cloneConstanic() returns {@code this} for CONSTANT FIRs.
 * <p>
 * <b>C3: CONSTANIC VALUE STABILITY</b><br>
 * A CONSTANIC FIR's value can only change due to coordination (re-evaluation
 * in a new context via CMFir or ConcatenationFiroe).
 * CONSTANIC branes' CONSTANT members remain accessible via search/getValue.
 * Only non-CONSTANT members may resolve differently in new context.
 * <p>
 * <b>C4: PARENT CHAIN INTEGRITY</b><br>
 * parentFir must not be reassigned after initial setup (enqueue or cloning)
 * except during context manipulation (CMFir.startPhaseB, ConcatenationFiroe.Stage B).
 * <p>
 * <b>=== PRE/POST CONDITIONS ===</b>
 * <p>
 * <b>step():</b><br>
 * PRE: isNye() == true OR no-op<br>
 * POST: State advances or remains same; never regresses
 * <p>
 * <b>getValue():</b><br>
 * PRE: isConstant() == true (or throws)<br>
 * POST: Returns numeric value; never modifies state
 * <p>
 * <b>cloneConstanic():</b><br>
 * PRE: isConstanic() == true<br>
 * POST: Returns {@code this} if CONSTANT; returns clone with updated parent if CONSTANIC
 * <p>
 * To create variations of CONSTANIC FIRs, use the copy() method which creates
 * new instances with different target states.
 */
public abstract class FIR implements Cloneable {
    protected final AST ast;
    protected final String comment;
    private boolean initialized;
    protected Nyes nyes;  // Protected to allow cloneConstanic to set state directly
    private FIR parentFir = null;  // The FIR that contains this FIR (set during enqueue)
    private final boolean ai;      // Auto-instruction: true if FIR was auto-generated (no AST)

    protected FIR(AST ast, String comment, boolean ai) {
        this.ast = ast;
        this.comment = comment;
        this.initialized = false;
        this.nyes = Nyes.UNINITIALIZED;
        this.ai = ai;
    }

    protected FIR(AST ast, String comment) {
        this(ast, comment, false);  // Default: not auto-generated
    }

    protected FIR(AST ast) {
        this(ast, null, false);
    }

    /**
     * Auto-instruction constructor for FIRs without AST.
     * Used when FIR is auto-generated by the system rather than parsed.
     */
    protected FIR(String comment) {
        this(null, comment, true);
    }

    /**
     * Returns the AST node associated with this FIR.
     * May be null for auto-generated FIRs.
     */
    public AST ast() {
        return ast;
    }

    /**
     * Returns the optional comment for this FIR.
     */
    public String comment() {
        return comment;
    }

    /**
     * Returns true if this FIR was auto-generated (auto-instruction).
     * Auto-generated FIRs have no associated AST and are created by the system
     * rather than being parsed from source code.
     */
    public boolean isAi() {
        return ai;
    }

    /**
     * Returns the source location for this FIR.
     * Returns UNKNOWN for auto-generated FIRs without AST.
     */
    public AST.SourceLocation sourceLocation() {
        if (ast != null) {
            return ast.sourceLocation();
        }
        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Finds the nearest source location by walking up the FIR parent chain.
     * Returns the first non-UNKNOWN location found, or UNKNOWN if none exist.
     */
    public AST.SourceLocation nearestSourceLocation() {
        // Try this FIR's location first
        AST.SourceLocation loc = sourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            return loc;
        }

        // Walk up parent chain
        FIR current = parentFir;
        while (current != null) {
            loc = current.sourceLocation();
            if (loc != AST.SourceLocation.UNKNOWN) {
                return loc;
            }
            current = current.parentFir;
        }

        return AST.SourceLocation.UNKNOWN;
    }

    /**
     * Gets the statement number of this FIR within its containing brane.
     * Returns -1 if not in a brane or if position cannot be determined.
     */
    public int getMyBraneStatementNumber() {
        BraneFiroe containingBrane = getMyBrane();
        if (containingBrane != null) {
            return containingBrane.getStatementIndex(this);
        }
        return -1;
    }

    /**
     * Returns a comprehensive location description including:
     * - Source file location (nearest in parent chain)
     * - Statement number in containing brane
     * - Auto-generated marker if applicable
     */
    public String getLocationDescription() {
        StringBuilder sb = new StringBuilder();

        AST.SourceLocation nearest = nearestSourceLocation();
        sb.append(nearest.toString());

        int stmtNum = getMyBraneStatementNumber();
        if (stmtNum >= 0) {
            sb.append(" (statement #").append(stmtNum + 1).append(")");
        }

        if (isAi()) {
            sb.append(" [auto-generated]");
        }

        return sb.toString();
    }


    /**
     * Formats an error message with the standard 3-item format:
     * 1. Source filename (from ExecutionContext)
     * 2. Line number or [ai] if unknown
     * 3. First ancestral brane line number (Brane@#)
     * <p>
     * Format: "filename.foo:line# Brane@# - message"
     * or: "filename.foo:[ai] Brane@# - message"
     *
     * @param message the error message to format
     * @return the formatted error message
     */
    public String formatErrorMessage(String message) {
        StringBuilder sb = new StringBuilder();

        // 1. Source filename
        ExecutionContext ctx = ExecutionContext.getCurrent();
        if (ctx != null) {
            sb.append(ctx.getSourceFilename());
        } else {
            sb.append("unknown.foo");
        }
        sb.append(":");

        // 2. Line number or [ai]
        AST.SourceLocation loc = nearestSourceLocation();
        if (loc != AST.SourceLocation.UNKNOWN) {
            sb.append("line ").append(loc.line());
        } else if (isAi()) {
            sb.append("[ai]");
        } else {
            sb.append("unknown");
        }

        // 3. Ancestral brane line number
        int braneLineNum = getMyBraneStatementNumber();
        sb.append(" Brane@").append(braneLineNum);

        // Append the actual message
        sb.append(" - ").append(message);

        return sb.toString();
    }

    /**
     * Returns whether this FIR has been initialized.
     */
    protected boolean isInitialized() {
        return initialized;
    }

    /**
     * Sets the initialized flag of this FIR.
     * This is separate from the Nyes state and tracks basic initialization.
     */
    protected void setInitialized() {
        this.initialized = true;
    }

    /**
     * Sets both the initialized flag and transitions to INITIALIZED Nyes state.
     * This is the recommended way to mark a FIR as initialized.
     */
    protected void markInitialized() {
        this.initialized = true;
        setNyes(Nyes.INITIALIZED);
    }

    /**
     * Returns the current NYE state of this FIR.
     */
    protected Nyes getNyes() {
        return nyes;
    }

    /**
     * Sets the NYE state of this FIR.
     * All changes to a Firoe's Nyes must be made through this method.
     * <p>
     * State transitions are validated using two-layer if-then logic.
     * Key constraints:
     * <ul>
     *   <li>No backward transitions (new state ordinal must be >= current ordinal)</li>
     *   <li>CONSTANIC is immutable except for transition to CONSTANT</li>
     *   <li>CONSTANT is terminal - no transitions allowed</li>
     *   <li>Forward skips are allowed (e.g., UNINITIALIZED â†’ CONSTANT for ValueFiroe)</li>
     * </ul>
     *
     * @param nyes the new state to transition to
     * @throws IllegalStateException if the transition is not allowed
     */
    protected void setNyes(Nyes nyes) {
        // Handle null current state (shouldn't happen, but be safe)
        if (this.nyes == null) {
            this.nyes = nyes;
            return;
        }

        // Two-layer if-then: outer checks current state, inner checks new state
        if (this.nyes == Nyes.UNINITIALIZED) {
            // From UNINITIALIZED, any forward transition is allowed
            if (nyes.ordinal() >= Nyes.UNINITIALIZED.ordinal()) {
                this.nyes = nyes;
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot transition from UNINITIALIZED to " + nyes));
            }
        } else if (this.nyes == Nyes.INITIALIZED) {
            if (nyes.ordinal() >= Nyes.INITIALIZED.ordinal()) {
                this.nyes = nyes;
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot transition backward from INITIALIZED to " + nyes));
            }
        } else if (this.nyes == Nyes.CHECKED) {
            if (nyes.ordinal() >= Nyes.CHECKED.ordinal()) {
                this.nyes = nyes;
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot transition backward from CHECKED to " + nyes));
            }
        } else if (this.nyes == Nyes.PRIMED) {
            if (nyes.ordinal() >= Nyes.PRIMED.ordinal()) {
                this.nyes = nyes;
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot transition backward from PRIMED to " + nyes));
            }
        } else if (this.nyes == Nyes.EVALUATING) {
            if (nyes.ordinal() >= Nyes.EVALUATING.ordinal()) {
                this.nyes = nyes;
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot transition backward from EVALUATING to " + nyes));
            }
        } else if (this.nyes == Nyes.CONSTANIC) {
            // CONSTANIC is immutable - only CONSTANT or same state allowed
            if (nyes == Nyes.CONSTANT) {
                this.nyes = nyes;
            } else if (nyes == Nyes.CONSTANIC) {
                // No-op, already in this state
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot change state from CONSTANIC to " + nyes +
                                      " - FIR is immutable once CONSTANIC"));
            }
        } else if (this.nyes == Nyes.CONSTANT) {
            // CONSTANT is terminal - no transitions allowed except same state
            if (nyes == Nyes.CONSTANT) {
                // No-op, already in this state
            } else {
                throw new IllegalStateException(
                    formatErrorMessage("Cannot change state from CONSTANT to " + nyes +
                                      " - FIR is immutable once CONSTANT"));
            }
        }
    }

    /**
     * Sets the parent FIR that contains this FIR.
     * This is called when this FIR is enqueued into a parent's braneMind.
     */
    protected void setParentFir(FIR parent) {
        this.parentFir = parent;
    }

    /**
     * Gets the parent FIR that contains this FIR.
     * Returns null if this FIR has no parent (e.g., root brane).
     */
    protected FIR getParentFir() {
        return parentFir;
    }

    /**
     * Returns true if state is EXACTLY CONSTANT.
     * Use when you need to distinguish CONSTANT from CONSTANIC.
     * <p>
     * "at Constant" means the FIR is at the CONSTANT state specifically.
     * @see #isConstant() for "at least CONSTANT" check
     */
    public boolean atConstant() {
        return getNyes() == Nyes.CONSTANT;
    }

    /**
     * Returns true if state is EXACTLY CONSTANIC.
     * Use when you need to distinguish CONSTANIC from CONSTANT.
     * <p>
     * "at Constanic" means the FIR is at the CONSTANIC state specifically,
     * not yet fully resolved but done stepping in current context.
     * <p>
     * Example: CMFir Phase A uses this to detect when to start Phase B.
     * @see #isConstanic() for "at least CONSTANIC" check
     */
    public boolean atConstanic() {
        return getNyes() == Nyes.CONSTANIC;
    }

    /**
     * Perform one step of evaluation on this FIR.
     * This method should advance the FIR's evaluation state by one step.
     * For simple values that don't require stepping, this can be a no-op.
     *
     * @return the amount of work done in this step:
     *         0 for empty transitions (no-op, already evaluated, or waiting)
     *         1 for meaningful work (state transitions, evaluations, searches)
     *         Values are accumulated for step counting
     */
    public abstract int step();

    /**
     * Query method returning false if an additional step on this FIR does not change it.
     * Returns true when an additional step would change the FIR.
     * Not Yet Evaluated (NYE) indicates the FIR requires further evaluation steps.
     * Anything before CONSTANIC is considered NYE.
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     */
    public boolean isNye() {
        return getNyes().ordinal() < Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANIC or higher (CONSTANIC OR CONSTANT).
     * "is Constanic" means the FIR has reached at least the CONSTANIC state.
     * <p>
     * Use when checking "is this FIR done with stepping?" regardless of
     * whether it reached full resolution or paused at constanic.
     * <p>
     * Example: cloneConstanic() precondition uses this since both states are valid.
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     * @see #atConstanic() for exact CONSTANIC check
     */
    public boolean isConstanic() {
        return getNyes().ordinal() >= Nyes.CONSTANIC.ordinal();
    }

    /**
     * Returns true if the state is CONSTANT or higher (currently just CONSTANT).
     * "is Constant" means the FIR is fully resolved.
     * <p>
     * Use when checking "is this FIR fully resolved?" - no context change
     * will affect its value.
     * Uses getNyes() to support subclass overrides (e.g., CMFir).
     * @see #atConstant() for exact CONSTANT check
     */
    public boolean isConstant() {
        return getNyes().ordinal() >= Nyes.CONSTANT.ordinal();
    }

    /**
     * Gets the value from this FIR if it represents a simple value.
     * For ValueFiroe and evaluated expressions, returns the integer value.
     *
     * @return the integer value
     * @throws UnsupportedOperationException if this FIR doesn't support getValue
     * @throws IllegalStateException         if this FIR is not fully evaluated
     */
    public long getValue() {
        throw new UnsupportedOperationException("getValue not supported for " + getClass().getSimpleName());
    }

    /**
     * Gets the BraneFiroe that contains this FIR in its statement list.
     * Chains through parent FIRs until finding one whose parent is a BraneFiroe.
     * <p>
     * The containing brane is the closest BraneFiroe in the FIR hierarchy,
     * representing the brane where this FIR appears as a statement.
     * <p>
     * Parallel expressions (such as operands in a+b) are at the "same height"
     * and all statements in a brane are parallel/same height. The height does
     * NOT deepen with deepening FIR structures - height only changes when
     * crossing brane boundaries.
     *
     * @return the containing BraneFiroe, or null if this FIR is not contained
     *         in a brane (e.g., at root level)
     */
    public BraneFiroe getMyBrane() {
        // Chain through parents until we find one whose parent is a BraneFiroe
        if (parentFir instanceof BraneFiroe bf) {
            return bf;
        }
        if (parentFir == null) {
            return null;
        }
        return parentFir.getMyBrane();
    }

    /**
     * Gets the closest brane-like container (BraneFiroe or ConcatenationFiroe).
     * <p>
     * Unlike getMyBrane() which only returns BraneFiroe, this method returns
     * brane-like containers that hold statements as direct children. This includes:
     * - BraneFiroe: The normal brane syntax { ... }
     * - ConcatenationFiroe: Joined branes that act as a single logical brane
     * <p>
     * This method does NOT return AssignmentFiroe or other FiroeWithBraneMind
     * that use braneMemory for internal expression evaluation rather than
     * statement storage.
     *
     * @return the containing brane-like FiroeWithBraneMind, or null if not found
     */
    public FiroeWithBraneMind getMyBraneContainer() {
        if (parentFir instanceof BraneFiroe || parentFir instanceof ConcatenationFiroe) {
            return (FiroeWithBraneMind) parentFir;
        }
        if (parentFir == null) {
            return null;
        }
        return parentFir.getMyBraneContainer();
    }

    /**
     * Gets the index of this FIR in its containing brane-like container's memory.
     * <p>
     * Works with BraneFiroe and ConcatenationFiroe.
     *
     * @return the index in the containing memory (0-based), or -1 if not found
     */
    public int getMyBraneContainerIndex() {
        if (parentFir instanceof BraneFiroe || parentFir instanceof ConcatenationFiroe) {
            return ((FiroeWithBraneMind) parentFir).getIndexOf(this);
        }
        if (parentFir == null) {
            return -1;
        }
        return parentFir.getMyBraneContainerIndex();
    }

    /**
     * Unwraps a chain of Constanicable wrappers to get the underlying resolved FIR.
     * <p>
     * This method follows the chain of {@link Constanicable#getResult()} calls until
     * it reaches a non-wrapper FIR (like BraneFiroe, ConcatenationFiroe, ValueFiroe, etc.)
     * or a wrapper that hasn't resolved yet (getResult() returns null).
     * <p>
     * Used by:
     * <ul>
     *   <li>ConcatenationFiroe - to unwrap identifiers/searches to their resolved branes</li>
     *   <li>CMFir - to unwrap the inner FIR for context manipulation</li>
     *   <li>Sequencer4Human - to unwrap assignments for rendering</li>
     * </ul>
     *
     * @param fir the FIR to unwrap
     * @return the underlying resolved FIR, or the original if not a Constanicable or not resolved
     */
    public static FIR unwrapConstanicable(FIR fir) {
        FIR current = fir;

        // Follow the wrapper chain while the FIR is constanic
        while (current != null && current.isConstanic()) {
            if (current instanceof Constanicable constanicable) {
                FIR result = constanicable.getResult();
                if (result == null || result == current) {
                    // Not resolved yet, or self-referential (containers like BraneFiroe)
                    return current;
                }
                current = result;
            } else {
                // Not a Constanicable, stop unwrapping
                return current;
            }
        }

        return current;
    }

    /**
     * Gets the hierarchical index of this FIR statement.
     * The index starts with 0 (root) and appends the statement index at each level.
     * Format example: [0, 0, 1, 2]
     */
    public FoolishIndex getMyIndex() {
        FoolishIndexBuilder builder = new FoolishIndexBuilder();
        FIR current = this;

        // Traverse up the hierarchy
        while (current != null) {
            int index = current.getMyBraneStatementNumber();
            if (index == -1) {
                // We reached the top (root or detached)
                // "Index always starts with 0"
                builder.prepend(0);
                break;
            } else {
                builder.prepend(index);
                // Move to the containing brane
                current = current.getMyBrane();
            }
        }

        return builder.build();
    }

    /**
     * Creates a copy of this FIR with optional target state.
     * <p>
     * This is the unified copying mechanism for all FIRs. The behavior depends on:
     * - If targetNyes is specified and different: clone and set new state
     * - If FIR is CONSTANIC and no target: return this (immutable, safe to share)
     * - Otherwise: wrap in CMFir for deferred context-sensitive copying
     *
     * @param targetNyes target Nyes state for the copy, or null to preserve current state
     * @return a copy of this FIR (may be this if immutable, or wrapped in CMFir)
     */
    public FIR copy(Nyes targetNyes) {
        // If target state specified and different, clone and set new state
        if (targetNyes != null && nyes != targetNyes) {
            FIR fresh = this.clone();
            // Set nyes directly - this is the ONLY place where we bypass setNyes()
            // Direct assignment is safe here because we just cloned
            fresh.nyes = targetNyes;
            return fresh;
        }
        if (isConstanic()) {
            return this;  // Immutable, safe to share
        } else {
            // Wrap in CMFir for deferred copying in new context
            if (this.ast() instanceof AST.Expr expr) {
                return new CMFir(this.ast(), this);
            } else {
                // Fallback: clone for non-Expr ASTs
                return this.clone();
            }
        }
    }

    /**
     * Shared recursion guard for valuableSelf() to prevent infinite loops.
     */
    protected static final ThreadLocal<Integer> RECURSION_DEPTH = ThreadLocal.withInitial(() -> 0);

    /**
     * Returns the "valuable self" of this FIR, resolving wrappers to their significant values.
     * <p>
     * - Returns Optional.of(this) by default (literal constants, branes, etc).
     * - Returns result of RHS for AssignmentFiroe.
     * - Returns resolved value for IdentifierFiroe.
     * - Returns Optional.empty() if the FIR tried to resolve but wasn't ready (CONSTANIC).
     * - Returns null if the FIR shouldn't have been called yet (pre-PRIMED).
     */
    public java.util.Optional<FIR> valuableSelf() {
        return java.util.Optional.of(this);
    }


    /**
     * Creates a shallow clone of this FIR.
     * Subclasses should override to provide deep cloning where needed
     * (e.g., for FIRs with braneMind or other mutable state).
     *
     * @return a shallow clone of this FIR
     */
    @Override
    protected FIR clone() {
        try {
            return (FIR) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Clone not supported for " + getClass().getSimpleName(), e);
        }
    }

    /**
     * Convenience method to clone with this FIR's parent and specified target state.
     * Equivalent to cloneConstanic(this.getParentFir(), targetNyes).
     *
     * @param targetNyes optional target state; if present, sets clone to this state
     * @return a clone with parent from this FIR
     * @throws IllegalStateException if called on a FIR that is not constanic
     */
    protected FIR cloneConstanic(java.util.Optional<Nyes> targetNyes) {
        return cloneConstanic(this.getParentFir(), targetNyes);
    }

    /**
     * Clones a CONSTANIC (or CONSTANT) FIR with updated parent chain.
     * <p>
     * This method is ONLY for cloning CONSTANIC or CONSTANT FIRs. It will throw
     * an exception if called on a FIR that is not constanic.
     * <p>
     * <b>Key behaviors:</b>
     * - CONSTANT FIRs: Returns this (shared completely - they're immutable)
     * - CONSTANIC FIRs: Creates a clone with updated parent chain to enable re-evaluation
     * <p>
     * <b>Lemma:</b> CONSTANT FIR cannot have non-CONSTANT children (fully immutable tree).
     * Therefore, CONSTANT FIRs can be shared completely without cloning.
     * <p>
     * <b>For CONSTANIC FIRs:</b> Parent chain must be updated to point to new objects
     * to enable re-evaluation in a new context. The clone uses a copy constructor
     * that recursively calls cloneConstanic on children with updated parents.
     *
     * @param newParent the new parent FIR for this clone
     * @param targetNyes optional target state; if present, sets clone to this state;
     *                   if empty, copies state from original
     * @return a clone with updated parent chain (CONSTANIC), or this (CONSTANT)
     * @throws IllegalStateException if called on a FIR that is not constanic
     */
    protected FIR cloneConstanic(FIR newParent, java.util.Optional<Nyes> targetNyes) {
        if (!isConstanic()) {
            throw new IllegalStateException(
                formatErrorMessage("cloneConstanic can only be called on CONSTANIC or CONSTANT FIRs, " +
                                  "but this FIR is in state: " + getNyes()));
        }

        if (isConstant()) {
            return this;  // Share CONSTANT FIRs completely (immutable tree)
        }

        // CONSTANIC: clone with new parent chain
        // Default implementation uses shallow clone
        // Subclasses with children (like FiroeWithBraneMind) must override
        FIR copy = this.clone();
        copy.setParentFir(newParent);

        // Set target state if specified, otherwise copy from original
        if (targetNyes.isPresent()) {
            copy.nyes = targetNyes.get();  // Direct assignment bypasses immutability check
        } else {
            copy.nyes = this.nyes;  // Copy original state
        }

        return copy;
    }

    /**
     * Creates a FIR from an AST expression.
     */
    protected static FIR createFiroeFromExpr(AST.Expr expr) {
        switch (expr) {
            case AST.IntegerLiteral literal -> {
                return new ValueFiroe(expr, literal.value());
            }
            case AST.BinaryExpr binary -> {
                return new BinaryFiroe(binary);
            }
            case AST.UnaryExpr unary -> {
                return new UnaryFiroe(unary);
            }
            case AST.IfExpr ifExpr -> {
                return new IfFiroe(ifExpr);
            }
            case AST.Brane brane -> {
                return new BraneFiroe(brane);
            }
            case AST.Concatenation concatenation -> {
                return new ConcatenationFiroe(concatenation);
            }
            case AST.DetachmentBrane detachBrane -> {
                return new DetachmentBraneFiroe(detachBrane);
            }
            case AST.Assignment assignment -> {
                return new AssignmentFiroe(assignment);
            }
            case AST.Identifier identifier -> {
                return new IdentifierFiroe(identifier);
            }
            case AST.RegexpSearchExpr regexpSearch -> {
                if (DerefSearchFiroe.isExactMatch(regexpSearch.pattern())) {
                    return new DerefSearchFiroe(regexpSearch);
                }
                return new RegexpSearchFiroe(regexpSearch);
            }
            case AST.OneShotSearchExpr oneShotSearch -> {
                return new OneShotSearchFiroe(oneShotSearch);
            }
            case AST.DereferenceExpr dereferenceExpr -> {
                AST.RegexpSearchExpr synthetic = new AST.RegexpSearchExpr(dereferenceExpr.anchor(), SearchOperator.REGEXP_LOCAL, dereferenceExpr.coordinate().toString());
                return new DerefSearchFiroe(synthetic, dereferenceExpr);
            }
            case AST.SeekExpr seekExpr -> {
                return new SeekFiroe(seekExpr);
            }
            case AST.UnanchoredSeekExpr unanchoredSeekExpr -> {
                return new UnanchoredSeekFiroe(unanchoredSeekExpr);
            }
            case AST.StayFoolishExpr stayFoolish -> {
                // SF marker wraps expression in SFMarkFiroe for re-coordination
                FIR innerFir = createFiroeFromExpr(stayFoolish.expr());
                return new SFMarkFiroe(stayFoolish, innerFir);
            }
            case AST.StayFullyFoolishExpr stayFullyFoolish -> {
                // SFF marker (<<==>> syntax) is temporarily disabled
                return new NKFiroe("SFF marker (<<==>> syntax) not yet implemented");
            }
            default -> {
                // Placeholder for unsupported types
                return new NKFiroe();
            }
        }
    }
}

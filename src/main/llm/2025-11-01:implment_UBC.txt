Let's beging implementing the UBC anew. It's okay if this new code duplicates existing functionality from FiroeVM. It is supposed to replace existing fvm implementation, so put everything in ubc directory parallel to fvm. Please read the README.md to understand UBC design. The UnicelluarBraneComputer should be initiated with a Brane Insoe and AB context. The corresponding BraneFiroe is created with only the AST attached.

Note: A **Fooler**, for lack of a better concise way to describe them, is a person who develops Foolish. A Fooler might say the variable is *nye* (says 'nigh') when they encounter a FIR that has not yet been evaluated fully. 


The FIR:
 * The FIR is a new class that minimally holds the AST.
 * Optionally a constant comment member contained in a string.
 * It has query method `isNye()` (*NYE* - Not Yet Evaluated) returning False if additional step on this FIR does not change it. It returns True when additional step would change the FIR.
 * query method `abstract()` returns False only when all identifies are bound.
 * Some FIR's has a braneMind referring to a queue used to prioritize evaluation tasks. The choice of queue enables us to perform breadthfirst execution. Some branes, such as the ValueFiroe does not require a braneMind, so that brane would just not have one and related method such as `isNye()` would just return `False`. Perhaps make this a choice by inserting a `FiroeWithBraneMind` and `FiroeWithoutBraneMind` class in the middle layer.

The FIR being the internal representation of computation can have several values:
 * BraneFiroe. The states are 
  * The BraneFiroe's AST is used to create a list of Expression Firoe's. each Firoe is enqueued into the braneMind of the present BraneFiroe.
  * The BraneFiero is *NYE* until the queue is exhausted.
  * a step on the BraneFiroe finds the first *NYE* Firoe on the braneMind and takes a step on it. The Firoe at the top of braneMind is dequeued if after the step it is not *NYE* any more.
  * The FiroeWithBraneMind super-class method would just return `True` or `False` based on the length of the braneMind.

The implementations will be:
 * DetachmentBraneFiroe
  * Let's leave this class abstract for now.
 * ExpressionFiroe
  * ValueFiroe, for now has a single subclass of integral long values.
  * IfFiroe
   * The IfFiroe contains a series of other Firoe representing condition and values.
  * SearchUpFiroe
   * This is a Brane wrapper. It has a reference to a brane Firoe that should already exist at this point. (It may has only AST)
  * UnaryFiroe
   * the operator and the AST for the operand, which in one step converts to the operand Firoe. evaluation continues until operand is done, one more step computes the result of hte unary expression.
  * BinaryFiroe
   * the operator and the AST for the operand, which in one step converts to two Firoes, encued into braneMind, stepped until not *NYE*.
   * last step performs the binary operation.

The UBC object now has one most prominent interface with the outside, which is a step() method. the step method steps forward from braneMind until empty, at which time it returns False.
When a expression Firoe is not *NYE*, we need to retrieve it's value. this should be made available by a getter method. For BraneFiroe, the value of *FK* (Fully Known) brane is a frozen Env. for Non-brane expressions, the value is only integer right now, and the getter method should reflect that.
